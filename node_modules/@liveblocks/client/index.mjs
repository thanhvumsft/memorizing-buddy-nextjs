import {
  _ as __rest,
  r as remove,
  i as isLiveNode,
  a as isRoomEventName,
  S as ServerMsgCode,
  m as mergeStorageUpdates,
  W as WebsocketCloseCodes,
  C as ClientMsgCode,
  n as nn,
  b as isPlainObject,
  p as parseRoomAuthToken,
  c as isTokenExpired,
  d as isSameNodeOrChildOf,
  L as LiveObject,
  g as getTreesDiffOperations,
  O as OpSource,
  e as OpCode,
  f as isLiveList,
  t as tryParseJson,
  h as isJsonArray,
  j as compact,
  k as isRootCrdt,
  l as isJsonObject,
  o as errorIf,
} from "./shared.mjs";
export { q as LiveList, s as LiveMap, L as LiveObject } from "./shared.mjs";
const BACKOFF_RETRY_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4],
  BACKOFF_RETRY_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];
function makeOthers(userMap) {
  const users = Object.values(userMap).map((user) =>
    __rest(user, ["_hasReceivedInitialPresence"])
  );
  return {
    get count() {
      return users.length;
    },
    [Symbol.iterator]: () => users[Symbol.iterator](),
    map: (callback) => users.map(callback),
    toArray: () => users,
  };
}
function makeStateMachine(state, context, mockedEffects) {
  const effects = mockedEffects || {
    authenticate(auth, createWebSocket) {
      const rawToken = state.token,
        parsedToken = null !== rawToken && parseRoomAuthToken(rawToken);
      if (!parsedToken || isTokenExpired(parsedToken))
        return auth(context.roomId)
          .then(({ token: token }) => {
            if ("authenticating" !== state.connection.state) return;
            authenticationSuccess(
              parseRoomAuthToken(token),
              createWebSocket(token)
            ),
              (state.token = token);
          })
          .catch((er) =>
            (function (error) {
              "production" !== process.env.NODE_ENV &&
                console.error("Call to authentication endpoint failed", error);
              (state.token = null),
                updateConnection({ state: "unavailable" }),
                state.numberOfRetry++,
                (state.timeoutHandles.reconnect = effects.scheduleReconnect(
                  getRetryDelay()
                ));
            })(er instanceof Error ? er : new Error(String(er)))
          );
      authenticationSuccess(parsedToken, createWebSocket(rawToken));
    },
    send(messageOrMessages) {
      if (null == state.socket)
        throw new Error("Can't send message if socket is null");
      state.socket.send(JSON.stringify(messageOrMessages));
    },
    delayFlush: (delay) => setTimeout(tryFlushing, delay),
    startHeartbeatInterval: () => setInterval(heartbeat, 3e4),
    schedulePongTimeout: () => setTimeout(pongTimeout, 2e3),
    scheduleReconnect: (delay) => setTimeout(connect, delay),
  };
  function genericSubscribe(callback) {
    return (
      state.listeners.storage.push(callback),
      () => remove(state.listeners.storage, callback)
    );
  }
  function createOrUpdateRootFromMessage(message) {
    if (0 === message.items.length)
      throw new Error("Internal error: cannot load storage without items");
    state.root
      ? (function (items) {
          if (!state.root) return;
          const currentItems = new Map();
          state.items.forEach((liveCrdt, id) => {
            currentItems.set(id, liveCrdt._toSerializedCrdt());
          });
          const ops = getTreesDiffOperations(currentItems, new Map(items));
          notify(apply(ops, !1).updates);
        })(message.items)
      : (state.root = (function (items) {
          const [root, parentToChildren] = (function (items) {
            const parentToChildren = new Map();
            let root = null;
            for (const [id, crdt] of items)
              if (isRootCrdt(crdt)) root = [id, crdt];
              else {
                const tuple = [id, crdt],
                  children = parentToChildren.get(crdt.parentId);
                null != children
                  ? children.push(tuple)
                  : parentToChildren.set(crdt.parentId, [tuple]);
              }
            if (null == root) throw new Error("Root can't be null");
            return [root, parentToChildren];
          })(items);
          return LiveObject._deserialize(root, parentToChildren, {
            getItem: getItem,
            addItem: addItem,
            deleteItem: deleteItem,
            generateId: generateId,
            generateOpId: generateOpId,
            dispatch: storageDispatch,
            roomId: context.roomId,
          });
        })(message.items));
    for (const key in state.defaultStorageRoot)
      null == state.root.get(key) &&
        state.root.set(key, state.defaultStorageRoot[key]);
  }
  function addItem(id, liveItem) {
    state.items.set(id, liveItem);
  }
  function deleteItem(id) {
    state.items.delete(id);
  }
  function getItem(id) {
    return state.items.get(id);
  }
  function addToUndoStack(historyItem) {
    state.undoStack.length >= 50 && state.undoStack.shift(),
      state.isHistoryPaused
        ? state.pausedHistory.unshift(...historyItem)
        : state.undoStack.push(historyItem);
  }
  function storageDispatch(ops, reverse, storageUpdates) {
    state.isBatching
      ? (state.batch.ops.push(...ops),
        storageUpdates.forEach((value, key) => {
          state.batch.updates.storageUpdates.set(
            key,
            mergeStorageUpdates(
              state.batch.updates.storageUpdates.get(key),
              value
            )
          );
        }),
        state.batch.reverseOps.push(...reverse))
      : (addToUndoStack(reverse),
        (state.redoStack = []),
        dispatch(ops),
        notify({ storageUpdates: storageUpdates }));
  }
  function notify({
    storageUpdates: storageUpdates = new Map(),
    presence: presence = !1,
    others: otherEvents = [],
  }) {
    if (otherEvents.length > 0) {
      state.others = makeOthers(state.users);
      for (const event of otherEvents)
        for (const listener of state.listeners.others)
          listener(state.others, event);
    }
    if (presence)
      for (const listener of state.listeners["my-presence"]) listener(state.me);
    if (storageUpdates.size > 0)
      for (const subscriber of state.listeners.storage)
        subscriber(Array.from(storageUpdates.values()));
  }
  function getConnectionId() {
    if (
      "open" === state.connection.state ||
      "connecting" === state.connection.state
    )
      return state.connection.id;
    if (null !== state.lastConnectionId) return state.lastConnectionId;
    throw new Error(
      "Internal. Tried to get connection id but connection was never open"
    );
  }
  function generateId() {
    return `${getConnectionId()}:${state.clock++}`;
  }
  function generateOpId() {
    return `${getConnectionId()}:${state.opClock++}`;
  }
  function apply(item, isLocal) {
    const result = {
        reverse: [],
        updates: { storageUpdates: new Map(), presence: !1 },
      },
      createdNodeIds = new Set();
    for (const op of item)
      if ("presence" === op.type) {
        const reverse = { type: "presence", data: {} };
        for (const key in op.data) reverse.data[key] = state.me[key];
        if (
          ((state.me = Object.assign(Object.assign({}, state.me), op.data)),
          null == state.buffer.presence)
        )
          state.buffer.presence = op.data;
        else
          for (const key in op.data) state.buffer.presence[key] = op.data[key];
        result.reverse.unshift(reverse), (result.updates.presence = !0);
      } else {
        let source;
        if ((op.opId || (op.opId = generateOpId()), isLocal))
          source = OpSource.UNDOREDO_RECONNECT;
        else {
          source = state.offlineOperations.delete(nn(op.opId))
            ? OpSource.ACK
            : OpSource.REMOTE;
        }
        const applyOpResult = applyOp(op, source);
        if (applyOpResult.modified) {
          const parentId =
            "HasParent" === applyOpResult.modified.node.parent.type
              ? nn(
                  applyOpResult.modified.node.parent.node._id,
                  "Expected parent node to have an ID"
                )
              : void 0;
          (parentId && createdNodeIds.has(parentId)) ||
            (result.updates.storageUpdates.set(
              nn(applyOpResult.modified.node._id),
              mergeStorageUpdates(
                result.updates.storageUpdates.get(
                  nn(applyOpResult.modified.node._id)
                ),
                applyOpResult.modified
              )
            ),
            result.reverse.unshift(...applyOpResult.reverse)),
            (op.type !== OpCode.CREATE_LIST &&
              op.type !== OpCode.CREATE_MAP &&
              op.type !== OpCode.CREATE_OBJECT) ||
              createdNodeIds.add(nn(applyOpResult.modified.node._id));
        }
      }
    return result;
  }
  function applyOp(op, source) {
    switch (op.type) {
      case OpCode.DELETE_OBJECT_KEY:
      case OpCode.UPDATE_OBJECT:
      case OpCode.DELETE_CRDT: {
        const item = state.items.get(op.id);
        return null == item
          ? { modified: !1 }
          : item._apply(op, source === OpSource.UNDOREDO_RECONNECT);
      }
      case OpCode.SET_PARENT_KEY: {
        const item = state.items.get(op.id);
        return null == item
          ? { modified: !1 }
          : "HasParent" === item.parent.type && isLiveList(item.parent.node)
          ? item.parent.node._setChildKey(op.parentKey, item, source)
          : { modified: !1 };
      }
      case OpCode.CREATE_OBJECT:
      case OpCode.CREATE_LIST:
      case OpCode.CREATE_MAP:
      case OpCode.CREATE_REGISTER: {
        if (void 0 === op.parentId) return { modified: !1 };
        const parent = state.items.get(op.parentId);
        return null == parent
          ? { modified: !1 }
          : parent._attachChild(op, source);
      }
    }
  }
  function connect() {
    var _a, _b, _c, _d;
    if (
      "closed" !== state.connection.state &&
      "unavailable" !== state.connection.state
    )
      return null;
    const auth = (function (authentication, fetchPolyfill) {
        if ("public" === authentication.type) {
          if ("undefined" == typeof window && null == fetchPolyfill)
            throw new Error(
              "To use Liveblocks client in a non-dom environment with a publicApiKey, you need to provide a fetch polyfill."
            );
          return (room) =>
            fetchAuthEndpoint(fetchPolyfill || fetch, authentication.url, {
              room: room,
              publicApiKey: authentication.publicApiKey,
            });
        }
        if ("private" === authentication.type) {
          if ("undefined" == typeof window && null == fetchPolyfill)
            throw new Error(
              "To use Liveblocks client in a non-dom environment with a url as auth endpoint, you need to provide a fetch polyfill."
            );
          return (room) =>
            fetchAuthEndpoint(fetchPolyfill || fetch, authentication.url, {
              room: room,
            });
        }
        if ("custom" === authentication.type) {
          return (room) =>
            authentication.callback(room).then((response) => {
              if (!response || !response.token)
                throw new Error(
                  'Authentication error. We expect the authentication callback to return a token, but it does not. Hint: the return value should look like: { token: "..." }'
                );
              return response;
            });
        }
        throw new Error("Internal error. Unexpected authentication type");
      })(
        context.authentication,
        null !==
          (_b =
            null === (_a = context.polyfills) || void 0 === _a
              ? void 0
              : _a.fetch) && void 0 !== _b
          ? _b
          : context.fetchPolyfill
      ),
      createWebSocket = (function (liveblocksServer, WebSocketPolyfill) {
        if ("undefined" == typeof window && null == WebSocketPolyfill)
          throw new Error(
            "To use Liveblocks client in a non-dom environment, you need to provide a WebSocket polyfill."
          );
        const ws = WebSocketPolyfill || WebSocket;
        return (token) =>
          new ws(`${liveblocksServer}/?token=${token}&version=0.17.6`);
      })(
        context.liveblocksServer,
        null !==
          (_d =
            null === (_c = context.polyfills) || void 0 === _c
              ? void 0
              : _c.WebSocket) && void 0 !== _d
          ? _d
          : context.WebSocketPolyfill
      );
    updateConnection({ state: "authenticating" }),
      effects.authenticate(auth, createWebSocket);
  }
  function authenticationSuccess(token, socket) {
    socket.addEventListener("message", onMessage),
      socket.addEventListener("open", onOpen),
      socket.addEventListener("close", onClose),
      socket.addEventListener("error", onError),
      updateConnection({
        state: "connecting",
        id: token.actor,
        userInfo: token.info,
        userId: token.id,
      }),
      (state.idFactory = (function (connectionId) {
        let count = 0;
        return () => `${connectionId}:${count++}`;
      })(token.actor)),
      (state.socket = socket);
  }
  function onUpdatePresenceMessage(message) {
    const user = state.users[message.actor];
    if (
      void 0 !== message.targetActor ||
      null == user ||
      user._hasReceivedInitialPresence
    )
      return (
        (state.users[message.actor] =
          null == user
            ? {
                connectionId: message.actor,
                presence: message.data,
                id: void 0,
                info: void 0,
                _hasReceivedInitialPresence: !0,
              }
            : {
                id: user.id,
                info: user.info,
                connectionId: message.actor,
                presence: Object.assign(
                  Object.assign({}, user.presence),
                  message.data
                ),
                _hasReceivedInitialPresence: !0,
              }),
        {
          type: "update",
          updates: message.data,
          user: state.users[message.actor],
        }
      );
  }
  function onUserLeftMessage(message) {
    const userLeftMessage = message,
      user = state.users[userLeftMessage.actor];
    return user
      ? (delete state.users[userLeftMessage.actor],
        { type: "leave", user: user })
      : null;
  }
  function onRoomStateMessage(message) {
    const newUsers = {};
    for (const key in message.users) {
      const connectionId = Number.parseInt(key),
        user = message.users[key];
      newUsers[connectionId] = {
        connectionId: connectionId,
        info: user.info,
        id: user.id,
      };
    }
    return (state.users = newUsers), { type: "reset" };
  }
  function onEvent(message) {
    for (const listener of state.listeners.event)
      listener({ connectionId: message.actor, event: message.event });
  }
  function onUserJoinedMessage(message) {
    return (
      (state.users[message.actor] = {
        connectionId: message.actor,
        info: message.info,
        id: message.id,
        _hasReceivedInitialPresence: !0,
      }),
      state.me &&
        (state.buffer.messages.push({
          type: ClientMsgCode.UPDATE_PRESENCE,
          data: state.me,
          targetActor: message.actor,
        }),
        tryFlushing()),
      { type: "enter", user: state.users[message.actor] }
    );
  }
  function parseServerMessage(data) {
    return isJsonObject(data) ? data : null;
  }
  function onMessage(event) {
    if ("pong" === event.data)
      return void clearTimeout(state.timeoutHandles.pongTimeout);
    const messages = (function (text) {
      const data = tryParseJson(text);
      return void 0 === data
        ? null
        : isJsonArray(data)
        ? compact(data.map((item) => parseServerMessage(item)))
        : compact([parseServerMessage(data)]);
    })(event.data);
    if (null === messages || 0 === messages.length) return;
    const updates = { storageUpdates: new Map(), others: [] };
    for (const message of messages)
      switch (message.type) {
        case ServerMsgCode.USER_JOINED:
          updates.others.push(onUserJoinedMessage(message));
          break;
        case ServerMsgCode.UPDATE_PRESENCE: {
          const othersPresenceUpdate = onUpdatePresenceMessage(message);
          othersPresenceUpdate && updates.others.push(othersPresenceUpdate);
          break;
        }
        case ServerMsgCode.BROADCASTED_EVENT:
          onEvent(message);
          break;
        case ServerMsgCode.USER_LEFT: {
          const event = onUserLeftMessage(message);
          event && updates.others.push(event);
          break;
        }
        case ServerMsgCode.ROOM_STATE:
          updates.others.push(onRoomStateMessage(message));
          break;
        case ServerMsgCode.INITIAL_STORAGE_STATE: {
          const offlineOps = new Map(state.offlineOperations);
          createOrUpdateRootFromMessage(message),
            applyAndSendOfflineOps(offlineOps),
            null == _getInitialStateResolver || _getInitialStateResolver();
          break;
        }
        case ServerMsgCode.UPDATE_STORAGE:
          apply(message.ops, !1).updates.storageUpdates.forEach(
            (value, key) => {
              updates.storageUpdates.set(
                key,
                mergeStorageUpdates(updates.storageUpdates.get(key), value)
              );
            }
          );
          break;
      }
    notify(updates);
  }
  function onClose(event) {
    if (
      ((state.socket = null),
      clearTimeout(state.timeoutHandles.pongTimeout),
      clearInterval(state.intervalHandles.heartbeat),
      state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush),
      clearTimeout(state.timeoutHandles.reconnect),
      (state.users = {}),
      notify({ others: [{ type: "reset" }] }),
      event.code >= 4e3 && event.code <= 4100)
    ) {
      updateConnection({ state: "failed" });
      const error = new LiveblocksError(event.reason, event.code);
      for (const listener of state.listeners.error) listener(error);
      const delay = getRetryDelay(!0);
      state.numberOfRetry++,
        "production" !== process.env.NODE_ENV &&
          console.error(
            `Connection to Liveblocks websocket server closed. Reason: ${error.message} (code: ${error.code}). Retrying in ${delay}ms.`
          ),
        updateConnection({ state: "unavailable" }),
        (state.timeoutHandles.reconnect = effects.scheduleReconnect(delay));
    } else if (event.code === WebsocketCloseCodes.CLOSE_WITHOUT_RETRY)
      updateConnection({ state: "closed" });
    else {
      const delay = getRetryDelay();
      state.numberOfRetry++,
        "production" !== process.env.NODE_ENV &&
          console.warn(
            `Connection to Liveblocks websocket server closed (code: ${event.code}). Retrying in ${delay}ms.`
          ),
        updateConnection({ state: "unavailable" }),
        (state.timeoutHandles.reconnect = effects.scheduleReconnect(delay));
    }
  }
  function updateConnection(connection) {
    state.connection = connection;
    for (const listener of state.listeners.connection)
      listener(connection.state);
  }
  function getRetryDelay(slow = !1) {
    return slow
      ? BACKOFF_RETRY_DELAYS_SLOW[
          state.numberOfRetry < BACKOFF_RETRY_DELAYS_SLOW.length
            ? state.numberOfRetry
            : BACKOFF_RETRY_DELAYS_SLOW.length - 1
        ]
      : BACKOFF_RETRY_DELAYS[
          state.numberOfRetry < BACKOFF_RETRY_DELAYS.length
            ? state.numberOfRetry
            : BACKOFF_RETRY_DELAYS.length - 1
        ];
  }
  function onError() {}
  function onOpen() {
    clearInterval(state.intervalHandles.heartbeat),
      (state.intervalHandles.heartbeat = effects.startHeartbeatInterval()),
      "connecting" === state.connection.state &&
        (updateConnection(
          Object.assign(Object.assign({}, state.connection), { state: "open" })
        ),
        (state.numberOfRetry = 0),
        void 0 !== state.lastConnectionId &&
          ((state.buffer.presence = state.me), tryFlushing()),
        (state.lastConnectionId = state.connection.id),
        state.root &&
          state.buffer.messages.push({ type: ClientMsgCode.FETCH_STORAGE }),
        tryFlushing());
  }
  function heartbeat() {
    null != state.socket &&
      (clearTimeout(state.timeoutHandles.pongTimeout),
      (state.timeoutHandles.pongTimeout = effects.schedulePongTimeout()),
      state.socket.readyState === state.socket.OPEN &&
        state.socket.send("ping"));
  }
  function pongTimeout() {
    reconnect();
  }
  function reconnect() {
    state.socket &&
      (state.socket.removeEventListener("open", onOpen),
      state.socket.removeEventListener("message", onMessage),
      state.socket.removeEventListener("close", onClose),
      state.socket.removeEventListener("error", onError),
      state.socket.close(),
      (state.socket = null)),
      updateConnection({ state: "unavailable" }),
      clearTimeout(state.timeoutHandles.pongTimeout),
      state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush),
      clearTimeout(state.timeoutHandles.reconnect),
      clearInterval(state.intervalHandles.heartbeat),
      connect();
  }
  function applyAndSendOfflineOps(offlineOps) {
    if (0 === offlineOps.size) return;
    const messages = [],
      ops = Array.from(offlineOps.values()),
      result = apply(ops, !0);
    messages.push({ type: ClientMsgCode.UPDATE_STORAGE, ops: ops }),
      notify(result.updates),
      effects.send(messages);
  }
  function tryFlushing() {
    const storageOps = state.buffer.storageOperations;
    if (
      (storageOps.length > 0 &&
        storageOps.forEach((op) => {
          state.offlineOperations.set(nn(op.opId), op);
        }),
      null == state.socket || state.socket.readyState !== state.socket.OPEN)
    )
      return void (state.buffer.storageOperations = []);
    const now = Date.now();
    if (now - state.lastFlushTime > context.throttleDelay) {
      const messages = (function (state) {
        const messages = [];
        state.buffer.presence &&
          messages.push({
            type: ClientMsgCode.UPDATE_PRESENCE,
            data: state.buffer.presence,
          });
        for (const event of state.buffer.messages) messages.push(event);
        state.buffer.storageOperations.length > 0 &&
          messages.push({
            type: ClientMsgCode.UPDATE_STORAGE,
            ops: state.buffer.storageOperations,
          });
        return messages;
      })(state);
      if (0 === messages.length) return;
      effects.send(messages),
        (state.buffer = {
          messages: [],
          storageOperations: [],
          presence: null,
        }),
        (state.lastFlushTime = now);
    } else
      null != state.timeoutHandles.flush &&
        clearTimeout(state.timeoutHandles.flush),
        (state.timeoutHandles.flush = effects.delayFlush(
          context.throttleDelay - (now - state.lastFlushTime)
        ));
  }
  function getPresence() {
    return state.me;
  }
  function dispatch(ops) {
    state.buffer.storageOperations.push(...ops), tryFlushing();
  }
  let _getInitialStatePromise = null,
    _getInitialStateResolver = null;
  return {
    onClose: onClose,
    onMessage: onMessage,
    authenticationSuccess: authenticationSuccess,
    heartbeat: heartbeat,
    onNavigatorOnline: function () {
      "unavailable" === state.connection.state && reconnect();
    },
    simulateSocketClose: function () {
      state.socket && (state.socket = null);
    },
    simulateSendCloseEvent: function (event) {
      onClose(event);
    },
    onVisibilityChange: function (visibilityState) {
      "visible" === visibilityState &&
        "open" === state.connection.state &&
        heartbeat();
    },
    getUndoStack: () => state.undoStack,
    getItemsCount: () => state.items.size,
    connect: connect,
    disconnect: function () {
      state.socket &&
        (state.socket.removeEventListener("open", onOpen),
        state.socket.removeEventListener("message", onMessage),
        state.socket.removeEventListener("close", onClose),
        state.socket.removeEventListener("error", onError),
        state.socket.close(),
        (state.socket = null)),
        updateConnection({ state: "closed" }),
        state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush),
        clearTimeout(state.timeoutHandles.reconnect),
        clearTimeout(state.timeoutHandles.pongTimeout),
        clearInterval(state.intervalHandles.heartbeat),
        (state.users = {}),
        notify({ others: [{ type: "reset" }] }),
        (function () {
          for (const key in state.listeners) state.listeners[key] = [];
        })();
    },
    subscribe: function (first, second, options) {
      if (void 0 === second || "function" == typeof first) {
        if ("function" == typeof first) {
          return genericSubscribe(first);
        }
        throw new Error("Please specify a listener callback");
      }
      if (isLiveNode(first)) {
        const node = first;
        if (null == options ? void 0 : options.isDeep) {
          return (function (node, callback) {
            return genericSubscribe((updates) => {
              const relatedUpdates = updates.filter((update) =>
                isSameNodeOrChildOf(update.node, node)
              );
              relatedUpdates.length > 0 && callback(relatedUpdates);
            });
          })(node, second);
        }
        return (function (node, callback) {
          return genericSubscribe((updates) => {
            for (const update of updates)
              update.node._id === node._id && callback(update.node);
          });
        })(node, second);
      }
      if (!isRoomEventName(first))
        throw new Error(`"${first}" is not a valid event name`);
      const eventName = first,
        eventListener = second;
      return (
        state.listeners[eventName].push(eventListener),
        () => {
          const callbacks = state.listeners[eventName];
          remove(callbacks, eventListener);
        }
      );
    },
    updatePresence: function (overrides, options) {
      const oldValues = {};
      null == state.buffer.presence && (state.buffer.presence = {});
      for (const key in overrides) {
        const overrideValue = overrides[key];
        void 0 !== overrideValue &&
          ((state.buffer.presence[key] = overrideValue),
          (oldValues[key] = state.me[key]));
      }
      (state.me = Object.assign(Object.assign({}, state.me), overrides)),
        state.isBatching
          ? ((null == options ? void 0 : options.addToHistory) &&
              state.batch.reverseOps.push({
                type: "presence",
                data: oldValues,
              }),
            (state.batch.updates.presence = !0))
          : (tryFlushing(),
            (null == options ? void 0 : options.addToHistory) &&
              addToUndoStack([{ type: "presence", data: oldValues }]),
            notify({ presence: !0 }));
    },
    broadcastEvent: function (
      event,
      options = { shouldQueueEventIfNotReady: !1 }
    ) {
      (null == state.socket && 0 == options.shouldQueueEventIfNotReady) ||
        (state.buffer.messages.push({
          type: ClientMsgCode.BROADCAST_EVENT,
          event: event,
        }),
        tryFlushing());
    },
    batch: function (callback) {
      if (state.isBatching)
        throw new Error("batch should not be called during a batch");
      state.isBatching = !0;
      try {
        callback();
      } finally {
        (state.isBatching = !1),
          state.batch.reverseOps.length > 0 &&
            addToUndoStack(state.batch.reverseOps),
          state.batch.ops.length > 0 && (state.redoStack = []),
          state.batch.ops.length > 0 && dispatch(state.batch.ops),
          notify(state.batch.updates),
          (state.batch = {
            ops: [],
            reverseOps: [],
            updates: { others: [], storageUpdates: new Map(), presence: !1 },
          }),
          tryFlushing();
      }
    },
    undo: function () {
      if (state.isBatching)
        throw new Error("undo is not allowed during a batch");
      const historyItem = state.undoStack.pop();
      if (null == historyItem) return;
      state.isHistoryPaused = !1;
      const result = apply(historyItem, !0);
      notify(result.updates), state.redoStack.push(result.reverse);
      for (const op of historyItem)
        "presence" !== op.type && state.buffer.storageOperations.push(op);
      tryFlushing();
    },
    redo: function () {
      if (state.isBatching)
        throw new Error("redo is not allowed during a batch");
      const historyItem = state.redoStack.pop();
      if (null == historyItem) return;
      state.isHistoryPaused = !1;
      const result = apply(historyItem, !0);
      notify(result.updates), state.undoStack.push(result.reverse);
      for (const op of historyItem)
        "presence" !== op.type && state.buffer.storageOperations.push(op);
      tryFlushing();
    },
    pauseHistory: function () {
      (state.pausedHistory = []), (state.isHistoryPaused = !0);
    },
    resumeHistory: function () {
      (state.isHistoryPaused = !1),
        state.pausedHistory.length > 0 && addToUndoStack(state.pausedHistory),
        (state.pausedHistory = []);
    },
    getStorage: function () {
      return state.root
        ? new Promise((resolve) => resolve({ root: state.root }))
        : (null == _getInitialStatePromise &&
            (state.buffer.messages.push({ type: ClientMsgCode.FETCH_STORAGE }),
            tryFlushing(),
            (_getInitialStatePromise = new Promise(
              (resolve) => (_getInitialStateResolver = resolve)
            ))),
          _getInitialStatePromise.then(() => ({ root: nn(state.root) })));
    },
    selectors: {
      getConnectionState: function () {
        return state.connection.state;
      },
      getSelf: function () {
        return "open" === state.connection.state ||
          "connecting" === state.connection.state
          ? {
              connectionId: state.connection.id,
              id: state.connection.userId,
              info: state.connection.userInfo,
              presence: getPresence(),
            }
          : null;
      },
      getPresence: getPresence,
      getOthers: function () {
        return state.others;
      },
    },
  };
}
function createRoom(options, context) {
  var _a, _b;
  const initialPresence =
      null !== (_a = options.initialPresence) && void 0 !== _a
        ? _a
        : options.defaultPresence,
    initialStorage =
      null !== (_b = options.initialStorage) && void 0 !== _b
        ? _b
        : options.defaultStorageRoot,
    machine = makeStateMachine(
      (function (initialPresence, initialStorage) {
        return {
          connection: { state: "closed" },
          token: null,
          lastConnectionId: null,
          socket: null,
          listeners: {
            event: [],
            others: [],
            "my-presence": [],
            error: [],
            connection: [],
            storage: [],
          },
          numberOfRetry: 0,
          lastFlushTime: 0,
          timeoutHandles: { flush: null, reconnect: 0, pongTimeout: 0 },
          buffer: {
            presence: null == initialPresence ? {} : initialPresence,
            messages: [],
            storageOperations: [],
          },
          intervalHandles: { heartbeat: 0 },
          me: null == initialPresence ? {} : initialPresence,
          users: {},
          others: makeOthers({}),
          defaultStorageRoot: initialStorage,
          idFactory: null,
          clock: 0,
          opClock: 0,
          items: new Map(),
          root: void 0,
          undoStack: [],
          redoStack: [],
          isHistoryPaused: !1,
          pausedHistory: [],
          isBatching: !1,
          batch: {
            ops: [],
            updates: { storageUpdates: new Map(), presence: !1, others: [] },
            reverseOps: [],
          },
          offlineOperations: new Map(),
        };
      })(
        "function" == typeof initialPresence
          ? initialPresence(context.roomId)
          : initialPresence,
        "function" == typeof initialStorage
          ? initialStorage(context.roomId)
          : initialStorage
      ),
      context
    ),
    room = {
      id: context.roomId,
      getConnectionState: machine.selectors.getConnectionState,
      getSelf: machine.selectors.getSelf,
      subscribe: machine.subscribe,
      getPresence: machine.selectors.getPresence,
      updatePresence: machine.updatePresence,
      getOthers: machine.selectors.getOthers,
      broadcastEvent: machine.broadcastEvent,
      getStorage: machine.getStorage,
      batch: machine.batch,
      history: {
        undo: machine.undo,
        redo: machine.redo,
        pause: machine.pauseHistory,
        resume: machine.resumeHistory,
      },
      __INTERNAL_DO_NOT_USE: {
        simulateCloseWebsocket: machine.simulateSocketClose,
        simulateSendCloseEvent: machine.simulateSendCloseEvent,
      },
    };
  return {
    connect: machine.connect,
    disconnect: machine.disconnect,
    onNavigatorOnline: machine.onNavigatorOnline,
    onVisibilityChange: machine.onVisibilityChange,
    room: room,
  };
}
class LiveblocksError extends Error {
  constructor(message, code) {
    super(message), (this.code = code);
  }
}
function fetchAuthEndpoint(fetch, endpoint, body) {
  return fetch(endpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  })
    .then((res) => {
      if (!res.ok)
        throw new AuthenticationError(
          `Expected a status 200 but got ${res.status} when doing a POST request on "${endpoint}"`
        );
      return res.json().catch((er) => {
        throw new AuthenticationError(
          `Expected a JSON response when doing a POST request on "${endpoint}". ${er}`
        );
      });
    })
    .then((data) => {
      if (!isPlainObject(data) || "string" != typeof data.token)
        throw new AuthenticationError(
          `Expected a JSON response of the form \`{ token: "..." }\` when doing a POST request on "${endpoint}", but got ${JSON.stringify(
            data
          )}`
        );
      const { token: token } = data;
      return { token: token };
    });
}
class AuthenticationError extends Error {
  constructor(message) {
    super(message);
  }
}
function createClient(options) {
  const clientOptions = options,
    throttleDelay = (function (options) {
      if (void 0 === options.throttle) return 100;
      if (
        "number" != typeof options.throttle ||
        options.throttle < 80 ||
        options.throttle > 1e3
      )
        throw new Error("throttle should be a number between 80 and 1000.");
      return options.throttle;
    })(options),
    rooms = new Map();
  return (
    "undefined" != typeof window &&
      void 0 !== window.addEventListener &&
      window.addEventListener("online", () => {
        for (const [, room] of rooms) room.onNavigatorOnline();
      }),
    "undefined" != typeof document &&
      document.addEventListener("visibilitychange", () => {
        for (const [, room] of rooms)
          room.onVisibilityChange(document.visibilityState);
      }),
    {
      getRoom: function (roomId) {
        const internalRoom = rooms.get(roomId);
        return internalRoom ? internalRoom.room : null;
      },
      enter: function (roomId, options = {}) {
        var _a;
        let internalRoom = rooms.get(roomId);
        if (internalRoom) return internalRoom.room;
        if (
          (errorIf(
            options.defaultPresence,
            "Argument `defaultPresence` will be removed in @liveblocks/client 0.18. Please use `initialPresence` instead. For more info, see https://bit.ly/3Niy5aP"
          ),
          errorIf(
            options.defaultStorageRoot,
            "Argument `defaultStorageRoot` will be removed in @liveblocks/client 0.18. Please use `initialStorage` instead. For more info, see https://bit.ly/3Niy5aP"
          ),
          (internalRoom = createRoom(
            {
              initialPresence: options.initialPresence,
              initialStorage: options.initialStorage,
              defaultPresence: options.defaultPresence,
              defaultStorageRoot: options.defaultStorageRoot,
            },
            {
              roomId: roomId,
              throttleDelay: throttleDelay,
              polyfills: clientOptions.polyfills,
              WebSocketPolyfill: clientOptions.WebSocketPolyfill,
              fetchPolyfill: clientOptions.fetchPolyfill,
              liveblocksServer:
                (null == clientOptions
                  ? void 0
                  : clientOptions.liveblocksServer) ||
                "wss://liveblocks.net/v6",
              authentication: prepareAuthentication(clientOptions),
            }
          )),
          rooms.set(roomId, internalRoom),
          !options.DO_NOT_USE_withoutConnecting)
        ) {
          if ("undefined" == typeof atob) {
            if (
              null ==
              (null === (_a = clientOptions.polyfills) || void 0 === _a
                ? void 0
                : _a.atob)
            )
              throw new Error(
                "You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill"
              );
            global.atob = clientOptions.polyfills.atob;
          }
          internalRoom.connect();
        }
        return internalRoom.room;
      },
      leave: function (roomId) {
        const room = rooms.get(roomId);
        room && (room.disconnect(), rooms.delete(roomId));
      },
    }
  );
}
function prepareAuthentication(clientOptions) {
  const { publicApiKey: publicApiKey, authEndpoint: authEndpoint } =
    clientOptions;
  if (void 0 !== authEndpoint && void 0 !== publicApiKey)
    throw new Error(
      "You cannot use both publicApiKey and authEndpoint. Please use either publicApiKey or authEndpoint, but not both. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
    );
  if ("string" == typeof publicApiKey) {
    if (publicApiKey.startsWith("sk_"))
      throw new Error(
        "Invalid publicApiKey. You are using the secret key which is not supported. Please use the public key instead. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    if (!publicApiKey.startsWith("pk_"))
      throw new Error(
        "Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey"
      );
    return {
      type: "public",
      publicApiKey: publicApiKey,
      url:
        clientOptions.publicAuthorizeEndpoint ||
        "https://liveblocks.io/api/public/authorize",
    };
  }
  if ("string" == typeof authEndpoint)
    return { type: "private", url: authEndpoint };
  if ("function" == typeof authEndpoint)
    return { type: "custom", callback: authEndpoint };
  if (void 0 !== authEndpoint)
    throw new Error(
      "authEndpoint must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint"
    );
  throw new Error(
    "Invalid Liveblocks client options. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient"
  );
}
export { createClient };
